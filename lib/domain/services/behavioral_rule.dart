import '../entities/user_profile_entity.dart';
import '../entities/behavioral_insight_entity.dart';
import '../entities/transaction_entity.dart';
import '../entities/budget_entity.dart';
import '../entities/streak_entity.dart';
import '../entities/war_mode_entity.dart';
import '../value_objects/delivery_triggers.dart';
import '../value_objects/insight_category.dart';
import '../value_objects/life_stage.dart';

/// Interface for behavioral insight rules
/// All rules must implement this interface for the engine to execute
abstract class BehavioralRule {
  /// Unique identifier for this rule
  String get id;

  /// Human-readable name for this rule
  String get name;

  /// Description of what this rule does
  String get description;

  /// The category of insights this rule generates
  InsightCategory get category;

  /// Which triggers can activate this rule
  Set<DeliveryTrigger> get triggers;

  /// Priority of insights generated by this rule
  InsightPriority get defaultPriority;

  /// Check if this rule should run for the given profile
  /// Override to add custom logic (e.g., only run for certain personalities)
  bool shouldRunForProfile(UserProfileEntity profile) {
    return profile.isCategoryEnabled(category);
  }

  /// Check if this rule should run for the given trigger
  bool shouldRunForTrigger(DeliveryTrigger trigger) {
    return triggers.contains(trigger);
  }

  /// Evaluate the rule and generate an insight if conditions are met
  /// Returns null if no insight should be generated
  Future<BehavioralInsightEntity?> evaluate(RuleContext context);

  /// Estimate execution time for performance tracking
  /// Override if rule is known to be expensive
  Duration get estimatedExecutionTime => const Duration(milliseconds: 50);
}

/// Context provided to rules during evaluation
/// Contains all data and helper methods rules might need
abstract class RuleContext {
  /// User profile for personalization
  UserProfileEntity get profile;

  /// Current date/time for evaluation
  DateTime get now;

  /// Get all transactions (cached)
  List<TransactionEntity> get transactions;

  /// Get budget entity (if available)
  BudgetEntity? get budget;

  /// Get streak data (if available)
  StreakEntity? get streak;

  /// Get war mode status (if available)
  WarModeEntity? get warMode;

  /// Get transactions filtered by category
  List<TransactionEntity> getTransactionsByCategory(String category);

  /// Get transactions within a date range
  List<TransactionEntity> getTransactionsInDateRange(
    DateTime start,
    DateTime end,
  );

  /// Get total spending in a period
  double getTotalSpentInPeriod(DateTime start, DateTime end);

  /// Get total income in a period
  double getTotalIncomeInPeriod(DateTime start, DateTime end);

  /// Get average daily spend over the last N days
  double getAverageDailySpend({int days = 30});

  /// Get average weekly spend over the last N weeks
  double getAverageWeeklySpend({int weeks = 4});

  /// Check if a category is trending up (spending more than usual)
  bool isCategoryTrendingUp(String category, {double threshold = 1.2});

  /// Check if a category is trending down (spending less than usual)
  bool isCategoryTrendingDown(String category, {double threshold = 0.8});

  /// Get the most expensive category in a period
  String? getTopCategory(DateTime start, DateTime end);

  /// Get spending by category as a map
  Map<String, double> getSpendingByCategory(DateTime start, DateTime end);

  /// Get days until next recurring bill
  int? getDaysUntilNextBill();

  /// Get total of upcoming bills in next N days
  double getUpcomingBillsTotal({int days = 7});
}
