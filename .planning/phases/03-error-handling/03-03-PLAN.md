---
phase: 03-error-handling
plan: 03
type: execute
---

<objective>
Add error tracking and aggregation for debugging production issues.

Purpose: Create centralized error tracking that aggregates errors from all sources, making it easier to identify patterns and diagnose issues in production.

Output: ErrorTracker utility for error aggregation and history, error logging integrated throughout app.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/codebase/CONCERNS.md
@.planning/phases/03-error-handling/03-01-SUMMARY.md
@.planning/phases/03-error-handling/03-02-SUMMARY.md

# Key files from Phase 3 Plans 1-2:
@lib/models/app_error.dart
@lib/utils/error_display.dart
@lib/services/database_service.dart
@lib/services/analytics_service.dart
@lib/services/backup_service.dart

# Tech stack available:
- AppError class hierarchy
- ErrorDisplay utility for UI
- AppLogger for logging

# Established patterns:
- AppError with type, message, technicalDetails
- Component-specific loggers
- Error logging before throwing/displaying

# Current error tracking gaps (from CONCERNS.md):
- Difficult to debug production issues
- No error aggregation or history
- No way to see error patterns over time

# Issues being addressed:
- Need for error tracking and debugging capabilities
- Production issue diagnosis support
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ErrorTracker utility in lib/utils/error_tracker.dart</name>
  <files>lib/utils/error_tracker.dart</files>
  <action>Create ErrorTracker singleton class for error aggregation:

1. Singleton pattern (private constructor, static instance)
2. Private list: final List<TrackedError> _errorHistory = []
3. Maximum history size: static const int maxHistorySize = 100
4. TrackError model class:
   - error: AppError
   - timestamp: DateTime
   - context: String (screen/component where error occurred)
   - stackTrace: StackTrace?

Public methods:
- trackError(AppError error, String context, {StackTrace? stackTrace}): void
  - Adds to _errorHistory
  - Logs with AppLogger.errorTracker
  - Removes oldest if超过 maxHistorySize
  - Returns void

- getRecentErrors({int count = 20}): List<TrackedError>
  - Returns most recent N errors
  - Newest first

- getErrorsByType(AppErrorType type): List<TrackedError>
  - Returns all errors of specific type

- getErrorsByContext(String context): List<TrackedError>
  - Returns all errors from specific screen/component

- clearHistory(): void
  - Clears _errorHistory
  - Logs with AppLogger.errorTracker

- getErrorCount(): int
  - Returns current history size

- exportErrorLog(): String
  - Returns JSON string of all tracked errors
  - Includes timestamp, type, message, context
  - Use jsonEncode with toMap() on TrackedError

Add AppLogger.errorTracker in app_logger.dart if not present.

Do NOT persist to disk (memory only for this phase - persistence is Phase 2 work).</action>
  <verify>File exists at lib/utils/error_tracker.dart with singleton, trackError method, and query methods</verify>
  <done>ErrorTracker utility created with error history tracking and query capabilities</done>
</task>

<task type="auto">
  <name>Task 2: Update ErrorDisplay to integrate with ErrorTracker</name>
  <files>lib/utils/error_display.dart</files>
  <action>Modify showErrorSnackBar and showErrorDialog to call ErrorTracker:

1. Add ErrorTracker import
2. In showErrorSnackBar(), after logging, call:
   ```dart
   ErrorTracker().trackError(error, 'UI: SnackBar', stackTrace: error.stackTrace);
   ```

3. In showErrorDialog(), after logging, call:
   ```dart
   ErrorTracker().trackError(error, context, stackTrace: error.stackTrace);
   ```

4. Add context parameter to showErrorDialog for tracking

5. Create trackOnlyError() static method:
   - Takes BuildContext, AppError, String context
   - Logs error
   - Tracks in ErrorTracker
   - Does NOT show any UI (for background errors)

Update method signatures:
- showErrorDialog(BuildContext context, AppError error, {String? errorContext})
- trackOnlyError(BuildContext context, AppError error, String context)

Add ErrorTracker import at top.</action>
  <verify>ErrorDisplay calls ErrorTracker.trackError() in all error display methods</verify>
  <done>ErrorDisplay integrated with ErrorTracker, all errors tracked before display</done>
</task>

<task type="auto">
  <name>Task 3: Update services to track errors before throwing</name>
  <files>lib/services/database_service.dart, lib/services/analytics_service.dart, lib/services/backup_service.dart</files>
  <action>Add ErrorTracker tracking before throwing AppError in all services:

For each service:
1. Add ErrorTracker import
2. In each catch block, before throwing AppError:
   - Call ErrorTracker().trackError(error, context, stackTrace: st)
   - Context should be service name + operation (e.g., "DatabaseService.addTransaction")

Pattern:
```dart
try {
  // operation
} catch (e, st) {
  AppLogger.database.severe('Failed to add transaction', e);
  final appError = AppError(
    type: AppErrorType.database,
    message: 'Could not save transaction to database',
    technicalDetails: 'Transaction ID: ${transaction.id}',
    originalError: e,
    stackTrace: st,
  );
  ErrorTracker().trackError(appError, 'DatabaseService.addTransaction', stackTrace: st);
  throw appError;
}
```

Update all three services:
- DatabaseService: track all database operations
- AnalyticsService: track analysis and validation errors
- BackupService: track export/import errors

Do NOT track non-critical errors (individual transaction skips during import).</action>
  <verify>All services call ErrorTracker.trackError() before throwing AppError</verify>
  <done>Services track errors before throwing, error history captures all service-layer failures</done>
</task>

<task type="auto">
  <name>Task 4: Add ErrorTracker integration to TransactionProvider</name>
  <files>lib/providers/transaction_provider.dart</files>
  <action>Update TransactionProvider to track errors in ErrorTracker:

1. Add ErrorTracker import
2. In loadTransactions() catch block:
   - After creating AppError, track with context "TransactionProvider.loadTransactions"
   - Use stackTrace if available

3. In addTransaction(), deleteTransaction(), updateTransaction():
   - Track errors with appropriate context (e.g., "TransactionProvider.addTransaction")

Pattern:
```dart
try {
  // operation
} catch (e, st) {
  _error = e is AppError ? e : AppError.fromException(e, stackTrace: st);
  AppLogger.provider.severe('Failed to load transactions', _error);
  ErrorTracker().trackError(_error!, 'TransactionProvider.loadTransactions', stackTrace: st);
  notifyListeners();
}
```

Create AppLogger.provider in app_logger.dart if not present.</action>
  <verify>TransactionProvider tracks all errors with appropriate context</verify>
  <done>TransactionProvider integrates with ErrorTracker for error history</done>
</task>

<task type="auto">
  <name>Task 5: Create developer debug screen for viewing error history</name>
  <files>lib/screens/debug/error_history_screen.dart</files>
  <action>Create developer-only debug screen for viewing tracked errors:

1. Create lib/screens/debug/ directory if needed
2. Create error_history_screen.dart:
   - StatefulWidget
   - Title: "Error History (Debug)"
   - List of recent errors from ErrorTracker().getRecentErrors()
   - Each error shows: timestamp, type, message, context
   - Export button to share error log (via Share or clipboard)
   - Clear button to reset history
   - Only visible in debug mode (kDebugMode check)

3. Error list item format:
   - Type icon (mapped from AppErrorType)
   - Timestamp (relative time like "2 min ago")
   - Error message
   - Context in subtitle (smaller, gray)

4. Export function:
   - Calls ErrorTracker().exportErrorLog()
   - Copies to clipboard or shares (if platform supports)
   - Shows success SnackBar

5. Add to debug navigation or enable via gesture (not in main nav)

Import material.dart, flutter/foundation.dart for kDebugMode.

Do NOT add this screen to main navigation - it's developer-only.</action>
  <verify>File exists at lib/screens/debug/error_history_screen.dart with error list and export functionality</verify>
  <done>Debug screen created for viewing error history (developer-only, hidden from main nav)</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `flutter analyze` passes with no errors
- [ ] ErrorTracker imported and used in ErrorDisplay, all services, and TransactionProvider
- [ ] ErrorTracker singleton pattern correctly implemented
- [ ] Error history screen created but not in main navigation
- [ ] All errors tracked before throwing/displaying
</verification>

<success_criteria>

- ErrorTracker singleton created with history tracking
- All error paths (services, provider, UI) track errors
- Query methods available for filtering by type/context
- Error history limit enforced (max 100 errors)
- Debug screen available for viewing errors (developer-only)
- Export functionality for error logs
  </success_criteria>

<output>
After completion, create `.planning/phases/03-error-handling/03-03-SUMMARY.md`:

# Phase 3 Plan 3: Error Tracking Summary

**Added centralized error tracking with ErrorTracker utility and debug screen**

## Accomplishments

- Created ErrorTracker singleton for error aggregation
- Integrated error tracking across all services and UI
- Added query methods for filtering by type/context
- Created developer-only debug screen for viewing error history
- Added error log export functionality

## Files Created/Modified

- `lib/utils/error_tracker.dart` - New error tracking utility
- `lib/utils/error_display.dart` - ErrorTracker integration
- `lib/services/database_service.dart` - Error tracking added
- `lib/services/analytics_service.dart` - Error tracking added
- `lib/services/backup_service.dart` - Error tracking added
- `lib/providers/transaction_provider.dart` - Error tracking added
- `lib/screens/debug/error_history_screen.dart` - New debug screen
- `lib/utils/app_logger.dart` - Added AppLogger.errorTracker

## Decisions Made

- Memory-only error tracking (no persistence - saves for future phase)
- 100 error history limit prevents unbounded growth
- Debug screen hidden from main navigation (developer-only)
- Export to JSON for easy sharing and analysis

## Issues Encountered

None

## Next Step

Phase 3 complete - ready for Phase 4 (Settings Screen Refactor)
</output>
