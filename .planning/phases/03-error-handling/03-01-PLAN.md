---
phase: 03-error-handling
plan: 01
type: execute
---

<objective>
Standardize service layer error handling with consistent error types and propagation patterns.

Purpose: Create predictable error handling that services can use consistently, making debugging easier and error communication to the UI layer more structured.

Output: AppError class hierarchy, standardized service error handling, all services using AppError for exceptions.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/codebase/CONCERNS.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/ARCHITECTURE.md
@.planning/phases/01-logging-foundation/01-02-SUMMARY.md
@.planning/phases/01-logging-foundation/01-03-SUMMARY.md

# Key files from Phase 1 (logging foundation):
@lib/utils/app_logger.dart
@lib/services/database_service.dart
@lib/services/analytics_service.dart
@lib/services/backup_service.dart

# Tech stack available (from Phase 1):
- AppLogger utility with component-specific loggers
- Structured logging patterns (emoji prefixes, timestamps)
- logging package configured

# Established patterns (from Phase 1):
- Component-specific loggers (AppLogger.database, AppLogger.analytics, AppLogger.backup)
- Log levels: INFO for success, SEVERE for errors
- Error logging with context: `AppLogger.{component}.severe('message', error)`

# Current error handling issues (from CONCERNS.md):
- Mix of print statements, logging package, and silent failures
- Inconsistent error handling throughout services
- Generic catch blocks that don't provide context

# Issues being addressed:
- Inconsistent error handling (service layer)
- Difficult to debug production issues (no structured error context)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AppError class hierarchy in lib/models/app_error.dart</name>
  <files>lib/models/app_error.dart</files>
  <action>Create AppError base class with properties:
- message: String (user-friendly description)
- technicalDetails: String? (debug info)
- originalError: Object? (caught exception)
- stackTrace: StackTrace? (for debugging)

Create error type enum:
- database (SQLite operations)
- network (future: for API calls)
- validation (input validation failures)
- backup (import/export operations)
- unknown (catch-all for unexpected errors)

Factory constructor AppError.fromException(Object? error, {AppErrorType? type}) that:
- If error is AppError, returns it
- If error is Exception, extracts message
- Otherwise, converts to string

Implement toString() for structured logging output.

Do NOT use excessive inheritance - single class with type enum is sufficient.</action>
  <verify>File exists at lib/models/app_error.dart, contains AppError class with all required properties and factory constructor</verify>
  <done>AppError class created with type enum, message, technicalDetails, originalError, stackTrace properties, and fromException factory</done>
</task>

<task type="auto">
  <name>Task 2: Update DatabaseService to use AppError for all exceptions</name>
  <files>lib/services/database_service.dart</files>
  <action>Replace all current throw/rethrow patterns with AppError:

For each catch block:
1. Create AppError with type=AppErrorType.database
2. Include operation context in message (e.g., "Failed to add transaction")
3. Pass original error and stackTrace
4. Log with AppLogger.database.severe() before throwing

Example pattern:
```dart
try {
  // database operation
} catch (e, st) {
  AppLogger.database.severe('Failed to add transaction', e);
  throw AppError(
    type: AppErrorType.database,
    message: 'Could not save transaction to database',
    technicalDetails: 'Transaction ID: ${transaction.id}',
    originalError: e,
    stackTrace: st,
  );
}
```

Methods to update:
- addTransaction()
- deleteTransaction()
- getAllTransactions()
- getTransactionById()
- updateTransaction()
- database getter
- _initDatabase()

Preserve existing AppLogger.database calls - they're valuable for context.</action>
  <verify>All catch blocks in DatabaseService throw AppError with type=AppErrorType.database</verify>
  <done>All database operations throw AppError instead of raw exceptions, with appropriate context and logging</done>
</task>

<task type="auto">
  <name>Task 3: Update AnalyticsService to use AppError for all exceptions</name>
  <files>lib/services/analytics_service.dart</files>
  <action>Replace silent catches (lines 33-35) and any unhandled errors with AppError:

1. Remove silent catch in _getAnalysis() that ignores invalid JSON
2. Add AppError with type=AppErrorType.validation for JSON parse failures
3. For any database errors that propagate, wrap in AppError with context
4. Add AppLogger.analytics calls before throwing AppError

Example for JSON parsing:
```dart
try {
  final budgets = jsonDecode(budgetsJson) as Map<String, dynamic>;
  budgets.forEach((key, value) {
    if (value is num) {
      categoryBudgets[key] = value.toDouble();
    }
  });
} catch (e, st) {
  AppLogger.analytics.severe('Invalid category budgets JSON', e);
  throw AppError(
    type: AppErrorType.validation,
    message: 'Invalid category budgets format',
    technicalDetails: 'JSON parse failed for: $budgetsJson',
    originalError: e,
    stackTrace: st,
  );
}
```

Add AppLogger.analytics import at top if not present.</action>
  <verify>No silent catch blocks remain; all errors thrown as AppError with type=AppErrorType.validation or .database</verify>
  <done>All AnalyticsService errors throw AppError with appropriate type, no silent failures</done>
</task>

<task type="auto">
  <name>Task 4: Update BackupService to use AppError for all exceptions</name>
  <files>lib/services/backup_service.dart</files>
  <action>Replace current rethrow patterns with AppError:

For exportData() catch block (line 30-32):
- Wrap error in AppError(type: AppErrorType.backup, message: 'Failed to export data')

For _exportSettings() catch block (lines 45-48):
- Currently returns empty map on error - this is acceptable for graceful degradation
- Add AppLogger.backup.severe() before returning empty map (already present)
- No need to throw for settings export failure - non-critical

For importData() catch block around transaction import (lines 91-94):
- Currently continues with skippedCount++ - this is acceptable for partial import
- Wrap individual transaction failures in AppError but don't throw (continue processing)
- Log with AppLogger.backup.warning() for skipped transactions

For _importSettings() errors:
- Wrap in AppError(type: AppErrorType.backup, message: 'Failed to import settings')

Add AppLogger import if not present (should already be there).</action>
  <verify>Critical errors (export failures, settings import) throw AppError with type=AppErrorType.backup; individual transaction skips are logged but don't throw</verify>
  <done>BackupService uses AppError for critical failures, logs warnings for non-critical issues during import</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `flutter analyze` passes with no errors
- [ ] All service files (database_service.dart, analytics_service.dart, backup_service.dart) import and use AppError
- [ ] No raw rethrow statements remain in service files
- [ ] AppLogger calls present before all AppError throws
</verification>

<success_criteria>

- AppError class created with all required properties and type enum
- All services throw AppError instead of raw exceptions
- Error messages include operation context for debugging
- AppLogger calls present for all errors before throwing
- No silent failures in critical paths (database operations, exports)
- Graceful degradation preserved where appropriate (partial imports, non-critical settings)
  </success_criteria>

<output>
After completion, create `.planning/phases/03-error-handling/03-01-SUMMARY.md`:

# Phase 3 Plan 1: Service Error Handling Summary

**Standardized service layer error handling with AppError class hierarchy**

## Accomplishments

- Created AppError class with structured error types and context
- Updated DatabaseService to throw AppError for all database operations
- Updated AnalyticsService to use AppError, removed silent failures
- Updated BackupService to use AppError for critical failures

## Files Created/Modified

- `lib/models/app_error.dart` - New error class hierarchy
- `lib/services/database_service.dart` - AppError for database operations
- `lib/services/analytics_service.dart` - AppError for validation/analysis errors
- `lib/services/backup_service.dart` - AppError for backup operations

## Decisions Made

- Single AppError class with type enum (not inheritance) - simpler and sufficient
- Graceful degradation preserved for non-critical failures (partial imports)
- All critical paths throw structured errors with context

## Issues Encountered

None

## Next Step

Ready for 03-02-PLAN.md - Standardize UI error display patterns
</output>
